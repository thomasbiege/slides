- symlink attack in graph.c (z:61) pktSizeDistribPie(), wird in http.c benutzt -> also root
- glibc2.1/sysdeps/posix/tempname.c enthaelt __gen_tempname(), welches von den t*mp*() calls
  benutzt wird
  wie folgt wird der code generiert:
    /* Get some more or less random data.  */
    __gettimeofday (&tv, NULL);
    value += ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec ^ __getpid ();

    for (count = 0; count < TMP_MAX; value += 7777, ++count)
    {
      uint64_t v = value;

      /* Fill in the random bits.  */
      XXXXXX[0] = letters[v % 62];
      v /= 62;
      XXXXXX[1] = letters[v % 62];
      v /= 62;
      XXXXXX[2] = letters[v % 62];
      v /= 62;
      XXXXXX[3] = letters[v % 62];
      v /= 62;
      XXXXXX[4] = letters[v % 62];
      v /= 62;
      XXXXXX[5] = letters[v % 62];

      if (openit)
    	{
	      fd = (largefile
		          ? __open (tmpl, O_RDWR | O_CREAT | O_EXCL, 0600)
		          : __open64 (tmpl, O_RDWR | O_CREAT | O_EXCL, 0600));
	      if (fd >= 0)
	      {
	        __set_errno (save_errno);
	        return fd;
	      }
	      else if (errno != EEXIST)
	        /* Any other error will apply also to other names we might
	          try, and there are 2^32 or so of them, so give up now. */
	        return -1;
	    }
      else
	    {
	      struct stat st;
	      if (__xstat (_STAT_VER, tmpl, &st) < 0)
	      {
	        if (errno == ENOENT)
		      {
		        __set_errno (save_errno);
		        return 0;
		      }
	        else
		        /* Give up now. */
		        return -1;
	      }
	    }
    }

    /* We got out of the loop because we ran out of combinations to try.  */
    __set_errno (EEXIST);
    return -1;
  }


- glibc2.1/sysdeps/posix/tempname.c __path_search() kann zum bufferoverflow fuehren
    dlen = strlen(dir)
    [...]
    if (tmpl_len < dlen + 1 + plen + 6 + 1)
    {
      __set_errno (EINVAL);
      return -1;
    }

    sprintf (tmpl, "%.*s/%.*sXXXXXX", (int) dlen, dir, (int) plen, pfx);

  dir wird duch $TMPDIR angegeben, wenn der 5. param von __path_search true ist.
  durch einen integer overflow kann die if-schleife umganegen werden, was
  bei sprintf() zu einem BOF fuehrt.
  s. auch tempnam(3)

- handleHTTPrequest()
  nicht exploitable, weilmax. 256 zeichen kopiert werden wir aber 580+ zeichen brauchen
  um an den stack zu gelangen

- sendString() bzw. senStringLen() koennen zu stack of fuehren, wenn das argument > 2*BUF_SIZE
  (2048) ist

- returnHTTPpage()
  zeile